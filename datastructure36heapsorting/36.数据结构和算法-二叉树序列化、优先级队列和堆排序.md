# <center>36. 二叉树序列化、优先级队列和堆排序<center>
@[TOC](数据结构和算法)

具体代码请看：**[NDKPractice项目的datastructure36heapsorting](https://github.com/EastUp/NDKPractice/tree/master/datastructure36heapsorting)**

# 知识点：



## 1. 二叉树的序列化和反序列化

### 1.1 序列化

```c++
/**
 * 序列化
 */
void serializeTree(TreeNode<char> *pNode, string &str) {
    if(!pNode){
        str.append("#");
        return;
    }

    // 先添加根节点
    str.append(string(1,pNode->data));

    // 再左节点
    serializeTree(pNode->left,str);

    // 再右节点
    serializeTree(pNode->right,str);

}
```

### 1.2 反序列化

```c++
/**
 * 反序列化 (ABD##E##C#F##)
 * 注意：必须要传 2 级指针，如果是一级指针这只是传过来的数组，++的时候是不会对数组有影响的
 */
TreeNode<char> *deserializeTree(char **str) {
    if(**str == '#'){
        *str += 1;
        return NULL;
    }

    TreeNode<char> *node = new TreeNode<char>(**str);
    *str += 1;

    // 解析左边的
    node->left = deserializeTree(str);
    // 解析右边的
    node->right = deserializeTree(str);

    return node;
}
```



## 2. 优先级队列

数组转二叉树规律(前提：`index 从 1 开始`)：

left(左节点) = 父节点角标 * 2  
right（右节点） = 父节点角标 * 2 + 1

- `最大堆`：父节点永远比子节点大。
- `最小堆`：父节点永远比子节点小。



## 3. 堆排序





















